<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÊñΩË®≠‰∫àÁ¥Ñ„Ç´„É¨„É≥„ÉÄ„Éº</title>
    
    <!-- CACHE CONTROL -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            background: #f8f9fa;
            color: #333;
        }
        
        .header {
            background: white;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .header h1 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 24px;
        }
        
        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .csv-upload {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .csv-upload input[type="file"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        
        .btn-primary {
            background: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background: #0056b3;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #1e7e34;
        }
        
        .btn-info {
            background: #17a2b8;
            color: white;
        }
        
        .btn-info:hover {
            background: #138496;
        }
        
        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        .status-badge {
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: 500;
            display: none;
        }
        
        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .calendar-navigation {
            background: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        
        .nav-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .nav-btn {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .nav-btn:hover {
            background: #e9ecef;
        }
        
        .week-info {
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }
        
        .calendar-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
            margin: 0 20px;
        }
        
        .calendar-grid {
            display: grid;
            grid-template-columns: 150px repeat(7, 1fr);
            min-height: 600px;
        }
        
        .room-header, .day-header {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 12px 8px;
            font-weight: 600;
            font-size: 13px;
            text-align: center;
            color: #495057;
        }
        
        .room-header {
            background: #e9ecef;
            display: flex;
            align-items: center;
            justify-content: center;
            writing-mode: horizontal-tb;
            text-align: center;
        }
        
        .day-header {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .day-name {
            font-size: 12px;
            color: #6c757d;
        }
        
        .day-date {
            font-size: 16px;
            color: #333;
        }
        
        .today .day-date {
            color: #007bff;
            font-weight: 700;
        }
        
        .calendar-cell {
            border: 1px solid #dee2e6;
            min-height: 120px;
            position: relative;
            padding: 4px;
            background: white;
        }
        
        .room-cell {
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: #495057;
            writing-mode: horizontal-tb;
            text-align: center;
            padding: 8px 4px;
        }
        
        .event-item {
            background: #007bff;
            color: white;
            padding: 3px 6px;
            margin: 2px 0;
            border-radius: 3px;
            font-size: 11px;
            line-height: 1.2;
            cursor: pointer;
            word-wrap: break-word;
            overflow: hidden;
        }
        
        .event-time {
            font-size: 10px;
            opacity: 0.9;
            margin-bottom: 1px;
        }
        
        .event-title {
            font-weight: 500;
        }
        
        .room-sakura .event-item { background: #ff69b4; }
        .room-violet .event-item { background: #9370db; }
        .room-telework-a .event-item { background: #87ceeb; }
        .room-telework-b .event-item { background: #90ee90; color: #333; }
        
        .loading, .no-events {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 16px;
        }
        
        .admin-panel {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 0 20px 20px 20px;
            display: none;
        }
        
        .admin-panel h3 {
            margin-top: 0;
            color: #495057;
        }
        
        .events-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 10px;
        }
        
        #statusMessage {
            margin: 10px 20px;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        
        @media (max-width: 768px) {
            .calendar-grid {
                grid-template-columns: 100px repeat(7, 1fr);
            }
            
            .room-header, .day-header {
                padding: 8px 4px;
                font-size: 12px;
            }
            
            .calendar-cell {
                min-height: 80px;
                padding: 2px;
            }
            
            .event-item {
                font-size: 10px;
                padding: 2px 4px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ÊñΩË®≠‰∫àÁ¥Ñ„Ç´„É¨„É≥„ÉÄ„Éº</h1>
        
        <div class="header-controls">
            <div class="csv-upload">
                <input type="file" id="csvFileInput" accept=".csv" />
                <button id="csvUploadBtn" class="btn btn-info">üìÑ CSV Âèñ„ÇäËæº„Åø</button>
            </div>
            <button id="adminToggle" class="btn btn-success">üîß ÁÆ°ÁêÜ„É¢„Éº„Éâ</button>
            <div id="statusBadge" class="status-badge"></div>
        </div>
    </div>
    
    <div id="adminPanel" class="admin-panel">
        <h3>üìã „Ç§„Éô„É≥„ÉàÁÆ°ÁêÜ</h3>
        <div id="eventsList" class="events-list">
            <p>Ë™≠„ÅøËæº„Åø‰∏≠...</p>
        </div>
        <button id="refreshBtn" class="btn btn-primary">üîÑ Êõ¥Êñ∞</button>
    </div>
    
    <div id="statusMessage"></div>
    
    <div class="calendar-navigation">
        <div class="nav-controls">
            <button id="prevWeekBtn" class="nav-btn">‚Äπ ÂâçÈÄ±</button>
            <button id="todayBtn" class="nav-btn">‰ªäÊó•</button>
            <button id="nextWeekBtn" class="nav-btn">Ê¨°ÈÄ± ‚Ä∫</button>
        </div>
        <div class="week-info" id="weekInfo">2025Âπ¥7Êúà28Êó• - 8Êúà3Êó•</div>
    </div>
    
    <div class="calendar-container">
        <div id="loading" class="loading">Ë™≠„ÅøËæº„Åø‰∏≠...</div>
        <div id="noEvents" class="no-events" style="display: none;">‰∫àÁ¥Ñ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>
        <div id="calendar" class="calendar-grid" style="display: none;"></div>
    </div>

    <!-- External libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/encoding-japanese@1.0.30/encoding.min.js"></script>
    
    <script>
        // Grid Calendar Implementation
        const ROOMS = ['‰ºöË≠∞ÂÆ§(„Åï„Åè„Çâ)', 'Áõ∏Ë´áÂÆ§(„Çπ„Éü„É¨„Éª„Ç≥„Çπ„É¢„Çπ)', '„ÉÜ„É¨„ÉØ„Éº„ÇØ„É´„Éº„É†A', '„ÉÜ„É¨„ÉØ„Éº„ÇØ„É´„Éº„É†B'];
        const ROOM_COLORS = {
            '‰ºöË≠∞ÂÆ§(„Åï„Åè„Çâ)': 'room-sakura',
            'Áõ∏Ë´áÂÆ§(„Çπ„Éü„É¨„Éª„Ç≥„Çπ„É¢„Çπ)': 'room-violet', 
            '„ÉÜ„É¨„ÉØ„Éº„ÇØ„É´„Éº„É†A': 'room-telework-a',
            '„ÉÜ„É¨„ÉØ„Éº„ÇØ„É´„Éº„É†B': 'room-telework-b'
        };
        
        let currentWeekStart = new Date();
        let currentEvents = [];
        let adminMode = false;
    </script>
    
    <script>
        // Grid Calendar Functions
        
        // Get Monday of current week
        function getWeekStart(date = new Date()) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1);
            return new Date(d.setDate(diff));
        }
        
        // Format date for display
        function formatDate(date) {
            return date.toLocaleDateString('ja-JP', {
                month: 'numeric',
                day: 'numeric'
            });
        }
        
        // Format week range
        function formatWeekRange(start) {
            const end = new Date(start);
            end.setDate(start.getDate() + 6);
            
            return `${start.getFullYear()}Âπ¥${start.getMonth() + 1}Êúà${start.getDate()}Êó• - ${end.getMonth() + 1}Êúà${end.getDate()}Êó•`;
        }
        
        // Get day name in Japanese
        function getDayName(dayIndex) {
            const days = ['Êó•', 'Êúà', 'ÁÅ´', 'Ê∞¥', 'Êú®', 'Èáë', 'Âúü'];
            return days[dayIndex];
        }
        
        // Initialize current week to Monday of this week
        currentWeekStart = getWeekStart();
        
        // Render calendar grid
        function renderCalendar() {
            const calendar = document.getElementById('calendar');
            const weekInfo = document.getElementById('weekInfo');
            
            // Update week info
            weekInfo.textContent = formatWeekRange(currentWeekStart);
            
            // Clear calendar
            calendar.innerHTML = '';
            
            // Create header row
            const headerRow = document.createElement('div');
            headerRow.style.display = 'contents';
            
            // Empty top-left cell
            const emptyCell = document.createElement('div');
            emptyCell.className = 'room-header';
            emptyCell.textContent = 'ÈÉ®Â±ã';
            headerRow.appendChild(emptyCell);
            
            // Day headers
            for (let i = 0; i < 7; i++) {
                const date = new Date(currentWeekStart);
                date.setDate(currentWeekStart.getDate() + i);
                
                const dayHeader = document.createElement('div');
                dayHeader.className = 'day-header';
                if (isToday(date)) dayHeader.classList.add('today');
                
                const dayName = document.createElement('div');
                dayName.className = 'day-name';
                dayName.textContent = getDayName(date.getDay());
                
                const dayDate = document.createElement('div');
                dayDate.className = 'day-date';
                dayDate.textContent = formatDate(date);
                
                dayHeader.appendChild(dayName);
                dayHeader.appendChild(dayDate);
                headerRow.appendChild(dayHeader);
            }
            
            calendar.appendChild(headerRow);
            
            // Create room rows
            ROOMS.forEach(room => {
                const roomRow = document.createElement('div');
                roomRow.style.display = 'contents';
                
                // Room name cell
                const roomCell = document.createElement('div');
                roomCell.className = 'room-cell';
                roomCell.textContent = room;
                roomRow.appendChild(roomCell);
                
                // Day cells for this room
                for (let i = 0; i < 7; i++) {
                    const date = new Date(currentWeekStart);
                    date.setDate(currentWeekStart.getDate() + i);
                    
                    const dayCell = document.createElement('div');
                    dayCell.className = `calendar-cell ${ROOM_COLORS[room]}`;
                    
                    // Add events for this room and date
                    const dayEvents = getEventsForRoomAndDate(room, date);
                    dayEvents.forEach(event => {
                        const eventEl = document.createElement('div');
                        eventEl.className = 'event-item';
                        
                        const timeEl = document.createElement('div');
                        timeEl.className = 'event-time';
                        timeEl.textContent = formatEventTime(event);
                        
                        const titleEl = document.createElement('div');
                        titleEl.className = 'event-title';
                        titleEl.textContent = event.name;
                        
                        eventEl.appendChild(timeEl);
                        eventEl.appendChild(titleEl);
                        dayCell.appendChild(eventEl);
                    });
                    
                    roomRow.appendChild(dayCell);
                }
                
                calendar.appendChild(roomRow);
            });
        }
        
        // Check if date is today
        function isToday(date) {
            const today = new Date();
            return date.toDateString() === today.toDateString();
        }
        
        // Get events for specific room and date
        function getEventsForRoomAndDate(room, date) {
            return currentEvents.filter(event => {
                const eventDate = new Date(event.start);
                return event.room === room && 
                       eventDate.toDateString() === date.toDateString();
            }).sort((a, b) => new Date(a.start) - new Date(b.start));
        }
        
        // Format event time
        function formatEventTime(event) {
            const start = new Date(event.start);
            const end = new Date(event.end);
            return `${formatTime(start)}-${formatTime(end)}`;
        }
        
        // Format time as HH:MM
        function formatTime(date) {
            return date.toLocaleTimeString('ja-JP', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });
        }
        
        // Navigation functions
        function goToPreviousWeek() {
            currentWeekStart.setDate(currentWeekStart.getDate() - 7);
            renderCalendar();
        }
        
        function goToNextWeek() {
            currentWeekStart.setDate(currentWeekStart.getDate() + 7);
            renderCalendar();
        }
        
        function goToToday() {
            currentWeekStart = getWeekStart();
            renderCalendar();
        }
        
        // CSV Upload function
        window.uploadCSV = async function() {
            const fileInput = document.getElementById('csvFileInput');
            const uploadBtn = document.getElementById('csvUploadBtn');
            const file = fileInput ? fileInput.files[0] : null;
            
            if (!file) {
                alert('CSV„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }
            
            if (uploadBtn) {
                uploadBtn.disabled = true;
                uploadBtn.textContent = 'Ë™≠„ÅøËæº„Åø‰∏≠...';
            }
            
            try {
                console.log('üö® [csv] Reading file:', file.name, 'Size:', file.size);
                
                // Read file as array buffer
                const arrayBuffer = await file.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                
                // Detect encoding and convert to UTF-8
                let text;
                if (typeof Encoding !== 'undefined') {
                    const detectedEncoding = Encoding.detect(uint8Array);
                    console.log('üö® [csv] Detected encoding:', detectedEncoding);
                    
                    if (detectedEncoding === 'SJIS' || detectedEncoding === 'EUCJP') {
                        const unicodeArray = Encoding.convert(uint8Array, {
                            to: 'UNICODE',
                            from: detectedEncoding
                        });
                        text = Encoding.codeToString(unicodeArray);
                    } else {
                        text = new TextDecoder('utf-8').decode(arrayBuffer);
                    }
                } else {
                    console.warn('üö® [csv] Encoding library not available, using UTF-8');
                    text = new TextDecoder('utf-8').decode(arrayBuffer);
                }
                
                console.log('üö® [csv] CSV text length:', text.length);
                console.log('üö® [csv] CSV first 200 chars:', text.substring(0, 200));
                
                // Parse CSV using PapaParse
                if (typeof Papa === 'undefined') {
                    console.error('üö® [csv] PapaParse library not available');
                    showStatusBadge('PapaParse„É©„Ç§„Éñ„É©„É™„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì', 'error');
                    return;
                }
                
                Papa.parse(text, {
                    header: true,
                    skipEmptyLines: true,
                    complete: async function(results) {
                        console.log('üö® [csv] ‚úÖ CSV parsed successfully');
                        console.log('üö® [csv] Raw parsed CSV data:', results.data);
                        console.log('üö® [csv] Number of rows:', results.data.length);
                        
                        let parsedCsvData = results.data;
                        const errors = []; // „Ç®„É©„Éº„ÇíË®òÈå≤„Åô„ÇãÈÖçÂàó

                        // === ÊúÄÁµÇ‰øÆÊ≠£„É≠„Ç∏„ÉÉ„ÇØÔºöÊúÄÂàù„ÅÆ„Éá„Éº„ÇøË°å„Åå„Éò„ÉÉ„ÉÄ„Éº„Åæ„Åü„ÅØË™¨ÊòéË°å„ÅÆÂ†¥Âêà„Å´„Çπ„Ç≠„ÉÉ„Éó ===
                        if (parsedCsvData.length > 0) {
                            const firstActualRow = parsedCsvData[0]; // results.data[0]„ÅØCSV„ÅÆ2Ë°åÁõÆ„Å´„ÅÇ„Åü„Çã

                            // ÈáçË¶Å„Å™Âàó„ÅÆ„Éá„Éº„Çø„Åå„Äå‰∫àÁ¥Ñ„Åó„Åü„ÅÑÊó•‰ªò„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Äç„ÅÆ„Çà„ÅÜ„Å™Ë™¨ÊòéÊñá„Åß„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                            const isInstructionRow = (
                                firstActualRow['5:date'] === "‰∫àÁ¥Ñ„Åó„Åü„ÅÑÊó•‰ªò„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ" ||
                                firstActualRow['7:checkbox'] === "‰ºöË≠∞ÂÆ§(„Åï„Åè„Çâ)„ÅÆ‰∫àÁ¥Ñ„Åó„Åü„ÅÑÊôÇÈñì„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ [‚Äª‰ªïÊßò‰∏ä30ÂàÜÂçò‰Ωç„ÅÆÈÅ∏ÊäûÈ†ÖÁõÆ„Åß„Åô„Åå„ÄÅÂøÖ„ÅöÈÄ£Á∂ö„Åó„Åü1ÊôÇÈñìÂçò‰Ωç„Åß‰∫àÁ¥Ñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ]" ||
                                firstActualRow['8:checkbox'] === "Áõ∏Ë´áÂÆ§(„Çπ„Éü„É¨„Éª„Ç≥„Çπ„É¢„Çπ)„ÅÆ‰∫àÁ¥Ñ„Åó„Åü„ÅÑÊôÇÈñì„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ [‚Äª‰ªïÊßò‰∏ä30ÂàÜÂçò‰Ωç„ÅÆÈÅ∏ÊäûÈ†ÖÁõÆ„Åß„Åô„Åå„ÄÅÂøÖ„ÅöÈÄ£Á∂ö„Åó„Åü1ÊôÇÈñìÂçò‰Ωç„Åß‰∫àÁ¥Ñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ]" ||
                                firstActualRow['234:checkbox'] === "„ÉÜ„É¨„ÉØ„Éº„ÇØ„É´„Éº„É†A„ÅÆ‰∫àÁ¥Ñ„Åó„Åü„ÅÑÊôÇÈñì„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ [‚Äª‰ªïÊßò‰∏ä30ÂàÜÂçò‰Ωç„ÅÆÈÅ∏ÊäûÈ†ÖÁõÆ„Åß„Åô„Åå„ÄÅÂøÖ„ÅöÈÄ£Á∂ö„Åó„Åü1ÊôÇÈñìÂçò‰Ωç„Åß‰∫àÁ¥Ñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ]" ||
                                firstActualRow['235:checkbox'] === "„ÉÜ„É¨„ÉØ„Éº„ÇØ„É´„Éº„É†B„ÅÆ‰∫àÁ¥Ñ„Åó„Åü„ÅÑÊôÇÈñì„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ [‚Äª‰ªïÊßò‰∏ä30ÂàÜÂçò‰Ωç„ÅÆÈÅ∏ÊäûÈ†ÖÁõÆ„Åß„Åô„Åå„ÄÅÂøÖ„ÅöÈÄ£Á∂ö„Åó„Åü1ÊôÇÈñìÂçò‰Ωç„Åß‰∫àÁ¥Ñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ]"
                            );

                            if (isInstructionRow) {
                                console.warn('‚ö†Ô∏è [csv] Detected an instruction/template row at the beginning (CSV line 2). Skipping this row.');
                                parsedCsvData.shift(); // ÊúÄÂàù„ÅÆË¶ÅÁ¥†„ÇíÂâäÈô§„Åó„Å¶„Çπ„Ç≠„ÉÉ„Éó
                            }
                        }
                        // === „Çπ„Ç≠„ÉÉ„Éó„É≠„Ç∏„ÉÉ„ÇØ„Åì„Åì„Åæ„Åß ===

                        console.log('üö® [csv] Processed CSV data after initial skip (if any):', parsedCsvData);
                        console.log('üö® [csv] Number of rows to process:', parsedCsvData.length);
                        
                        if (results.errors && results.errors.length > 0) {
                            console.warn('üö® [csv] Parse warnings:', results.errors);
                        }
                        
                        // Validate and convert CSV data
                        const validEvents = [];
                        
                        // ÈÄ£Á∂öÊôÇÈñìÂ∏Ø„ÇíÈõÜÁ¥Ñ„Åô„Çã„Åü„ÇÅ„ÅÆ„Éò„É´„Éë„ÉºÈñ¢Êï∞
                        function consolidateConsecutiveTimeSlots(timeSlots) {
                            if (!timeSlots || timeSlots.length === 0) return [];
                            if (timeSlots.length === 1) return timeSlots;
                            
                            console.log(`üö® [consolidate] Input slots:`, timeSlots);
                            
                            // ÊôÇÈñìÈ†Ü„Å´„ÇΩ„Éº„Éà
                            const sortedSlots = [...timeSlots].sort((a, b) => {
                                const timeA = a.start.split(':').map(n => parseInt(n));
                                const timeB = b.start.split(':').map(n => parseInt(n));
                                return (timeA[0] * 60 + timeA[1]) - (timeB[0] * 60 + timeB[1]);
                            });
                            
                            const consolidated = [];
                            let currentSlot = { ...sortedSlots[0] };
                            
                            for (let i = 1; i < sortedSlots.length; i++) {
                                const nextSlot = sortedSlots[i];
                                
                                // ÁèæÂú®„ÅÆ„Çπ„É≠„ÉÉ„Éà„ÅÆÁµÇ‰∫ÜÊôÇÈñì„Å®Ê¨°„ÅÆ„Çπ„É≠„ÉÉ„Éà„ÅÆÈñãÂßãÊôÇÈñì„ÅåÈÄ£Á∂ö„Åó„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                                if (currentSlot.end === nextSlot.start) {
                                    // ÈÄ£Á∂ö„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅÁµÇ‰∫ÜÊôÇÈñì„ÇíÂª∂Èï∑
                                    currentSlot.end = nextSlot.end;
                                    console.log(`üö® [consolidate] Merged slots: ${currentSlot.start}„Äú${currentSlot.end}`);
                                } else {
                                    // ÈÄ£Á∂ö„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÄÅÁèæÂú®„ÅÆ„Çπ„É≠„ÉÉ„Éà„ÇíÁµêÊûú„Å´ËøΩÂä†„Åó„ÄÅÊñ∞„Åó„ÅÑ„Çπ„É≠„ÉÉ„Éà„ÇíÈñãÂßã
                                    consolidated.push(currentSlot);
                                    currentSlot = { ...nextSlot };
                                }
                            }
                            
                            // ÊúÄÂæå„ÅÆ„Çπ„É≠„ÉÉ„Éà„ÇíËøΩÂä†
                            consolidated.push(currentSlot);
                            
                            console.log(`üö® [consolidate] Output slots:`, consolidated);
                            return consolidated;
                        }
                        
                        // üö® COMPREHENSIVE CSV HEADER ANALYSIS AND DEBUGGING
                        console.log('üö®üö®üö® [csv] ===== STARTING CSV PROCESSING ANALYSIS =====');
                        console.log('üö® [csv] Total rows found:', results.data.length);
                        
                        if (results.data.length > 0) {
                            const allHeaders = Object.keys(results.data[0]);
                            console.log('üö® [csv] ALL CSV HEADERS DETECTED:');
                            allHeaders.forEach((header, idx) => {
                                console.log(`üö® [csv] Header ${idx + 1}: "${header}"`);
                            });
                            
                            // Identify room-related columns
                            const roomColumns = allHeaders.filter(header => 
                                header.includes('‰ºöË≠∞ÂÆ§') || header.includes('Áõ∏Ë´áÂÆ§') || 
                                header.includes('„ÉÜ„É¨„ÉØ„Éº„ÇØ') || header.includes('ÊôÇÈñì')
                            );
                            console.log('üö® [csv] ROOM-RELATED COLUMNS FOUND:', roomColumns);
                            
                            // Show sample data from first row
                            console.log('üö® [csv] SAMPLE DATA FROM FIRST ROW:');
                            console.log('üö® [csv] - 5:date value:', results.data[0]['5:date']);
                            console.log('üö® [csv] - 244:lastname value:', results.data[0]['244:lastname']);
                            console.log('üö® [csv] - 244:firstname value:', results.data[0]['244:firstname']);
                            console.log('üö® [csv] - ‰ΩøÁî®ÁõÆÁöÑ column exists:', allHeaders.includes('‰ΩøÁî®ÁõÆÁöÑ„Å®Ê¥ªÂãïÂÜÖÂÆπ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'));
                            console.log('üö® [csv] - ÂõûÁ≠îÁï™Âè∑ value:', results.data[0]['ÂõûÁ≠îÁï™Âè∑']);
                        }
                        
                        parsedCsvData.forEach((row, index) => {
                            console.log(`üö®üö®üö® [csv] ===== PROCESSING ROW ${index + 1} =====`);
                            console.log(`üö® [csv] --- Processing new row ---`);
                            console.log(`üö® [csv] Raw row data (full object):`, row);
                            console.log(`üö® [csv] Keys available in this row:`, Object.keys(row));
                            console.log(`üö® [csv] Row ${index + 1} has ${Object.keys(row).length} columns`);
                            
                            // üö® CRITICAL: Log first 20 keys to identify exact header names
                            const rowKeys = Object.keys(row);
                            console.log(`üö® [csv] First 20 keys in row ${index + 1}:`);
                            rowKeys.slice(0, 20).forEach((key, idx) => {
                                console.log(`üö® [csv]   Key ${idx + 1}: "${key}" = "${row[key]}"`);
                            });
                            
                            // 1. ID EXTRACTION with detailed logging
                            const eventId = row['ÂõûÁ≠îÁï™Âè∑'] || `csv_${Date.now()}_${index}`;
                            console.log(`üö® [csv] Extracted ID: "${eventId}"`);
                            console.log(`üö® [csv] ID extraction - ÂõûÁ≠îÁï™Âè∑ exists:`, 'ÂõûÁ≠îÁï™Âè∑' in row);
                            console.log(`üö® [csv] ID extraction - ÂõûÁ≠îÁï™Âè∑ value:`, row['ÂõûÁ≠îÁï™Âè∑']);
                            
                            // 2. DATE EXTRACTION with detailed logging  
                            const dateStr = row['5:date'];
                            console.log(`üö® [csv] Extracted Date String: "${dateStr}"`);
                            console.log(`üö® [csv] Date extraction - 5:date exists:`, '5:date' in row);
                            console.log(`üö® [csv] Date extraction - 5:date value:`, row['5:date']);
                            
                            // 3. NAME EXTRACTION with detailed logging
                            let userName = '';
                            console.log(`üö® [csv] Name extraction - checking fields:`);
                            console.log(`üö® [csv]   244:lastname exists:`, '244:lastname' in row, 'value:', row['244:lastname']);
                            console.log(`üö® [csv]   244:firstname exists:`, '244:firstname' in row, 'value:', row['244:firstname']);
                            console.log(`üö® [csv]   91:lastname exists:`, '91:lastname' in row, 'value:', row['91:lastname']);
                            console.log(`üö® [csv]   91:firstname exists:`, '91:firstname' in row, 'value:', row['91:firstname']);
                            
                            if (row['244:lastname'] && row['244:firstname']) {
                                // Âêç + Âßì„ÅÆÈ†Ü„ÅßË°®Á§∫Ôºà‰æã: Â§™ÈÉé Â±±Áî∞Ôºâ
                                userName = `${row['244:firstname']} ${row['244:lastname']}`;
                                console.log(`üö® [csv] ‚úÖ Extracted Name from 244 fields: "${userName}"`);
                            } else if (row['91:lastname'] && row['91:firstname']) {
                                // Âêç + Âßì„ÅÆÈ†Ü„ÅßË°®Á§∫Ôºà‰æã: Â§™ÈÉé Â±±Áî∞Ôºâ
                                userName = `${row['91:firstname']} ${row['91:lastname']}`;
                                console.log(`üö® [csv] ‚úÖ Extracted Name from 91 fields: "${userName}"`);
                            } else {
                                userName = row['92:text'] || row['93:text'] || '‰∫àÁ¥ÑËÄÖ';
                                console.log(`üö® [csv] ‚úÖ Extracted Name from fallback: "${userName}"`);
                            }
                            
                            // 4. PURPOSE/TITLE EXTRACTION with detailed logging
                            const purposeColumn = '‰ΩøÁî®ÁõÆÁöÑ„Å®Ê¥ªÂãïÂÜÖÂÆπ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
                            console.log(`üö® [csv] Title extraction - purpose column exists:`, purposeColumn in row);
                            console.log(`üö® [csv] Title extraction - purpose column value:`, row[purposeColumn]);
                            
                            let eventTitle = row[purposeColumn] || userName || `‰∫àÁ¥Ñ ${eventId}`;
                            console.log(`üö® [csv] Extracted Title/Purpose: "${eventTitle}"`);
                            
                            if (!dateStr) {
                                console.error(`üö® [csv] ‚ùå Row ${index + 1}: NO DATE FOUND - Skipping row`);
                                const errorObj = {
                                    line: index + 2,
                                    errors: ['5:dateÂàó„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑ„ÅãÁ©∫„Åß„Åô'],
                                    data: {
                                        availableKeys: rowKeys.slice(0, 10),
                                        dateFieldValue: row['5:date']
                                    }
                                };
                                errors.push(errorObj);
                                return;
                            }
                            
                            // 5. CORRECTED ROOM AND TIME DETECTION USING ACTUAL CSV KEYS
                            console.log(`üö® [csv] ===== ROOM TIME DETECTION FOR ROW ${index + 1} (USING REAL CSV KEYS) =====`);
                            console.log(`üö® [csv] Row data with values (first 30):`, Object.fromEntries(Object.entries(row).slice(0, 30)));
                            
                            let rowEvents = [];
                            
                            // üö® STEP 1: Extract room name from '1:checkbox' column
                            let roomName = '';
                            const roomCheckboxValue = row['1:checkbox'];
                            console.log(`üö® [csv] Extracted room checkbox value (1:checkbox):`, roomCheckboxValue);
                            
                            if (roomCheckboxValue) {
                                // Remove text in brackets like "„Äê1ÊôÇÈñì100ÂÜÜ„Äë"
                                if (roomCheckboxValue.includes('„Äê')) {
                                    roomName = roomCheckboxValue.split('„Äê')[0].trim();
                                } else {
                                    roomName = roomCheckboxValue.trim();
                                }
                                
                                // Normalize room names
                                if (roomName.includes('‰ºöË≠∞ÂÆ§') && roomName.includes('„Åï„Åè„Çâ')) {
                                    roomName = '‰ºöË≠∞ÂÆ§(„Åï„Åè„Çâ)';
                                } else if (roomName.includes('Áõ∏Ë´áÂÆ§') && (roomName.includes('„Çπ„Éü„É¨') || roomName.includes('„Ç≥„Çπ„É¢„Çπ'))) {
                                    roomName = 'Áõ∏Ë´áÂÆ§(„Çπ„Éü„É¨„Éª„Ç≥„Çπ„É¢„Çπ)';
                                } else if (roomName.includes('„ÉÜ„É¨„ÉØ„Éº„ÇØ„É´„Éº„É†A')) {
                                    roomName = '„ÉÜ„É¨„ÉØ„Éº„ÇØ„É´„Éº„É†A';
                                } else if (roomName.includes('„ÉÜ„É¨„ÉØ„Éº„ÇØ„É´„Éº„É†B')) {
                                    roomName = '„ÉÜ„É¨„ÉØ„Éº„ÇØ„É´„Éº„É†B';
                                }
                                
                                console.log(`üö® [csv] Final determined roomName:`, roomName);
                            }
                            
                            // üö® STEP 2: BULLETPROOF TIME DATA EXTRACTION
                            console.log(`üö® [csv] ===== BULLETPROOF TIME DATA EXTRACTION =====`);
                            
                            // Define room-time column mappings
                            const roomTimeColumns = [
                                { room: '‰ºöË≠∞ÂÆ§(„Åï„Åè„Çâ)', columnKey: '7:checkbox' },
                                { room: 'Áõ∏Ë´áÂÆ§(„Çπ„Éü„É¨„Éª„Ç≥„Çπ„É¢„Çπ)', columnKey: '8:checkbox' },
                                { room: '„ÉÜ„É¨„ÉØ„Éº„ÇØ„É´„Éº„É†A', columnKey: '234:checkbox' },
                                { room: '„ÉÜ„É¨„ÉØ„Éº„ÇØ„É´„Éº„É†B', columnKey: '235:checkbox' }
                            ];
                            
                            let foundRoomName = '';
                            let foundTimeValue = '';
                            let timeColumnUsed = '';
                            
                            console.log(`üö® [csv] Checking all room-time columns for valid data...`);
                            
                            // Check each room-time column for data
                            for (const rtMapping of roomTimeColumns) {
                                const columnData = row[rtMapping.columnKey];
                                console.log(`üö® [csv] Checking column '${rtMapping.columnKey}' for ${rtMapping.room}:`, columnData);
                                
                                // STRICT validation: must be string, not null/undefined, and not empty after trim
                                if (columnData && 
                                    typeof columnData === 'string' && 
                                    columnData.trim() !== '') {
                                    
                                    foundTimeValue = columnData.trim();
                                    foundRoomName = rtMapping.room;
                                    timeColumnUsed = rtMapping.columnKey;
                                    
                                    console.log(`üö® [csv] ‚úÖ FOUND valid time data in '${rtMapping.columnKey}':`, foundTimeValue);
                                    console.log(`üö® [csv] ‚úÖ Room determined from time column: "${foundRoomName}"`);
                                    
                                    break; // Use first valid time data found
                                } else {
                                    console.log(`üö® [csv] Column '${rtMapping.columnKey}' invalid or empty`);
                                }
                            }
                            
                            // Override room name if '1:checkbox' has valid data (higher priority)
                            if (roomName && roomName.trim() !== '') {
                                console.log(`üö® [csv] ‚úÖ Using room name from 1:checkbox: "${roomName}" (overriding: "${foundRoomName}")`);
                                foundRoomName = roomName;
                            }
                            
                            console.log(`üö® [csv] FINAL EXTRACTION RESULTS:`);
                            console.log(`üö® [csv] ‚úÖ foundRoomName: "${foundRoomName}"`);
                            console.log(`üö® [csv] ‚úÖ foundTimeValue: "${foundTimeValue}"`);
                            console.log(`üö® [csv] ‚úÖ timeColumnUsed: "${timeColumnUsed}"`);
                            
                            // üö® STEP 3: STRICT VALIDATION AND EVENT CREATION
                            console.log(`üö® [csv] ===== STRICT VALIDATION BEFORE EVENT CREATION =====`);
                            
                            // ABSOLUTE requirement check - both foundTimeValue and foundRoomName must be valid
                            if (!foundTimeValue || typeof foundTimeValue !== 'string' || foundTimeValue.trim() === '') {
                                console.error(`üö® [csv] ‚ùå Row ${index + 1}: CRITICAL - foundTimeValue is invalid: "${foundTimeValue}"`);
                                const errorObj = {
                                    line: index + 2,
                                    errors: [`ÂøÖË¶Å„Å™ÊôÇÈñì„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇTime: "${foundTimeValue}"`],
                                    extractedData: { id: eventId, date: dateStr, name: userName, title: eventTitle },
                                    roomColumnAnalysis: roomTimeColumns.map(rt => ({
                                        room: rt.room,
                                        column: rt.columnKey,
                                        exists: rt.columnKey in row,
                                        value: row[rt.columnKey],
                                        hasData: !!(row[rt.columnKey] && row[rt.columnKey].trim())
                                    })),
                                    fullRowData: Object.fromEntries(Object.entries(row).filter(([key, value]) => value && value.trim() !== ''))
                                };
                                errors.push(errorObj);
                                console.error(`üö® [csv] ‚ùå Error object created:`, JSON.stringify(errorObj, null, 2));
                                // Skip this row completely
                                return;
                            }
                            
                            if (!foundRoomName || typeof foundRoomName !== 'string' || foundRoomName.trim() === '') {
                                console.error(`üö® [csv] ‚ùå Row ${index + 1}: CRITICAL - foundRoomName is invalid: "${foundRoomName}"`);
                                const errorObj = {
                                    line: index + 2,
                                    errors: [`ÂøÖË¶Å„Å™ÈÉ®Â±ãÂêç„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇRoom: "${foundRoomName}"`],
                                    extractedData: { id: eventId, date: dateStr, name: userName, title: eventTitle },
                                    roomColumnAnalysis: roomTimeColumns.map(rt => ({
                                        room: rt.room,
                                        column: rt.columnKey,
                                        exists: rt.columnKey in row,
                                        value: row[rt.columnKey],
                                        hasData: !!(row[rt.columnKey] && row[rt.columnKey].trim())
                                    })),
                                    fullRowData: Object.fromEntries(Object.entries(row).filter(([key, value]) => value && value.trim() !== ''))
                                };
                                errors.push(errorObj);
                                console.error(`üö® [csv] ‚ùå Error object created:`, JSON.stringify(errorObj, null, 2));
                                // Skip this row completely
                                return;
                            }
                            
                            console.log(`üö® [csv] ‚úÖ VALIDATION PASSED - Both room and time data are valid`);
                            console.log(`üö® [csv] ‚úÖ Proceeding with time parsing for: "${foundTimeValue}"`);
                            
                            // Parse the semicolon-separated time values with bulletproof error handling
                            const rawTimeSlots = parseUltraSafeTimeValue(foundTimeValue);
                            console.log(`üö® [csv] Parsed ${rawTimeSlots.length} raw time slots from "${foundTimeValue}":`, rawTimeSlots);
                            
                            // ÈÄ£Á∂ö„Åô„ÇãÊôÇÈñìÂ∏Ø„ÇíÈõÜÁ¥Ñ
                            const timeSlots = consolidateConsecutiveTimeSlots(rawTimeSlots);
                            console.log(`üö® [csv] Consolidated to ${timeSlots.length} time slots:`, timeSlots);
                            
                            if (timeSlots.length === 0) {
                                console.error(`üö® [csv] ‚ùå Row ${index + 1}: No valid time slots parsed from "${foundTimeValue}"`);
                                const errorObj = {
                                    line: index + 2,
                                    errors: [`ÊôÇÈñì„Éá„Éº„Çø„ÅÆËß£Êûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇRaw time: "${foundTimeValue}"`],
                                    extractedData: { id: eventId, date: dateStr, name: userName, title: eventTitle, room: foundRoomName },
                                    timeParsingAttempt: {
                                        rawTimeValue: foundTimeValue,
                                        timeValueType: typeof foundTimeValue,
                                        timeValueLength: foundTimeValue.length
                                    },
                                    fullRowData: Object.fromEntries(Object.entries(row).filter(([key, value]) => value && value.trim() !== ''))
                                };
                                errors.push(errorObj);
                                console.error(`üö® [csv] ‚ùå Error object created:`, JSON.stringify(errorObj, null, 2));
                                return;
                            }
                            
                            // Create events for each valid time slot
                            timeSlots.forEach((timeSlot, slotIndex) => {
                                console.log(`üö® [csv] Creating event ${slotIndex + 1} for ${foundRoomName} with slot:`, timeSlot);
                                
                                const eventObj = createUltraSafeEvent(
                                    eventId, 
                                    foundRoomName, 
                                    eventTitle, 
                                    dateStr, 
                                    timeSlot, 
                                    index, 
                                    slotIndex
                                );
                                
                                if (eventObj) {
                                    rowEvents.push(eventObj);
                                    console.log(`üö® [csv] ‚úÖ Successfully created event ${slotIndex + 1} for ${foundRoomName}:`, eventObj);
                                } else {
                                    console.error(`üö® [csv] ‚ùå Failed to create event for ${foundRoomName}, slot ${slotIndex + 1}`);
                                }
                            });
                            
                            console.log(`üö® [csv] Row ${index + 1} TOTAL EVENTS CREATED: ${rowEvents.length}`);
                            
                            // Add all events from this row to the main validEvents array
                            rowEvents.forEach(event => {
                                if (event) {
                                    validEvents.push(event);
                                    console.log(`üö® [csv] ‚úÖ Added event to validEvents array:`, event);
                                }
                            });
                            
                            // 6. DETAILED ERROR ANALYSIS AND REPORTING
                            if (rowEvents.length === 0) {
                                console.error(`üö® [csv] ‚ùå Row ${index + 1} produced NO EVENTS - DETAILED ANALYSIS:`);
                                
                                // Create comprehensive error report
                                const errorObj = {
                                    line: index + 2,
                                    errors: ['ÊôÇÈñì„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑ„ÅãËß£Êûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'],
                                    extractedData: {
                                        id: eventId,
                                        date: dateStr,
                                        name: userName,
                                        title: eventTitle
                                    },
                                    actualColumnAnalysis: {
                                        roomCheckbox: {
                                            column: '1:checkbox',
                                            exists: '1:checkbox' in row,
                                            value: row['1:checkbox'],
                                            hasData: !!(row['1:checkbox'] && row['1:checkbox'].trim())
                                        },
                                        timeColumns: ['7:checkbox', '8:checkbox', '234:checkbox', '235:checkbox'].map(col => ({
                                            column: col,
                                            exists: col in row,
                                            value: row[col],
                                            hasData: !!(row[col] && row[col].trim())
                                        }))
                                    },
                                    availableColumnsWithData: Object.entries(row)
                                        .filter(([key, value]) => value && value.trim() !== '')
                                        .slice(0, 20)
                                        .map(([key, value]) => ({ column: key, value: value.substring(0, 50) })),
                                    rowKeyCount: Object.keys(row).length
                                };
                                
                                errors.push(errorObj);
                                console.error(`üö® [csv] ‚ùå Detailed error object:`, JSON.stringify(errorObj, null, 2));
                                
                                // Additional debugging: Show all room-related columns
                                const roomRelatedColumns = Object.keys(row).filter(key => 
                                    key.includes('‰ºöË≠∞ÂÆ§') || key.includes('Áõ∏Ë´áÂÆ§') || 
                                    key.includes('„ÉÜ„É¨„ÉØ„Éº„ÇØ') || key.includes('ÊôÇÈñì')
                                );
                                console.error(`üö® [csv] ‚ùå Room-related columns found in row:`, roomRelatedColumns);
                                roomRelatedColumns.forEach(col => {
                                    console.error(`üö® [csv] ‚ùå   "${col}" = "${row[col]}"`);
                                });
                            } else {
                                console.log(`üö® [csv] ‚úÖ Row ${index + 1} successfully created ${rowEvents.length} events`);
                                rowEvents.forEach((event, idx) => {
                                    console.log(`üö® [csv] ‚úÖ   Event ${idx + 1}: ${event.name} in ${event.room} from ${event.start} to ${event.end}`);
                                });
                            }
                            
                            console.log(`üö®üö®üö® [csv] ===== FINISHED PROCESSING ROW ${index + 1} =====`);
                        });
                        
                        // üö® BULLETPROOF UTILITY FUNCTIONS - ZERO ERROR TOLERANCE
                        
                        function parseUltraSafeTimeValue(timeValue) {
                            console.log(`üö® [parseUltraSafeTimeValue] === ENTRY POINT ===`);
                            console.log(`üö® [parseUltraSafeTimeValue] Input:`, timeValue, `(type: ${typeof timeValue})`);
                            
                            const parsedSlots = [];
                            
                            // ABSOLUTE input validation - prevent ALL undefined/null errors
                            if (!timeValue || typeof timeValue !== 'string' || timeValue.trim() === '') {
                                console.error(`üö® [parseUltraSafeTimeValue] CRITICAL: Invalid input - returning empty array`);
                                console.error(`üö® [parseUltraSafeTimeValue] Input details: value="${timeValue}", type="${typeof timeValue}"`);
                                return parsedSlots; // Return empty array safely
                            }
                            
                            try {
                                // Safe normalize and split operations
                                const normalizedTimeRange = timeValue
                                    .replace(/Ôºö/g, ':')      // Full-width colon to half-width
                                    .replace(/„Äú/g, 'ÔΩû')      // Normalize wave dash
                                    .replace(/‚àí/g, 'ÔΩû')      // Em dash to wave dash
                                    .replace(/-/g, 'ÔΩû')      // Hyphen to wave dash
                                    .trim();
                                
                                console.log(`üö® [parseUltraSafeTimeValue] Normalized: "${normalizedTimeRange}"`);
                                
                                // SAFE split operation with validation
                                if (!normalizedTimeRange.includes(';')) {
                                    // Single time range
                                    const singleSlot = parseValidTimeSlot(normalizedTimeRange);
                                    if (singleSlot) {
                                        parsedSlots.push(singleSlot);
                                        console.log(`üö® [parseUltraSafeTimeValue] ‚úÖ Single slot parsed:`, singleSlot);
                                    }
                                } else {
                                    // Multiple time ranges
                                    const timeRanges = normalizedTimeRange.split(';')
                                        .map(t => t.trim())
                                        .filter(t => t && t.length > 3); // Filter out incomplete times like "11"
                                    
                                    console.log(`üö® [parseUltraSafeTimeValue] Split into ${timeRanges.length} ranges:`, timeRanges);
                                    
                                    timeRanges.forEach((range, idx) => {
                                        console.log(`üö® [parseUltraSafeTimeValue] Processing range ${idx + 1}: "${range}"`);
                                        const slot = parseValidTimeSlot(range);
                                        if (slot) {
                                            parsedSlots.push(slot);
                                            console.log(`üö® [parseUltraSafeTimeValue] ‚úÖ Valid slot ${idx + 1}:`, slot);
                                        } else {
                                            console.warn(`üö® [parseUltraSafeTimeValue] ‚ùå Invalid slot ${idx + 1}: "${range}"`);
                                        }
                                    });
                                }
                                
                            } catch (error) {
                                console.error(`üö® [parseUltraSafeTimeValue] EXCEPTION caught:`, error);
                                console.error(`üö® [parseUltraSafeTimeValue] Stack:`, error.stack);
                                // Return empty array on any error
                            }
                            
                            console.log(`üö® [parseUltraSafeTimeValue] === RESULT: ${parsedSlots.length} valid slots ===`, parsedSlots);
                            return parsedSlots;
                        }
                        
                        function parseValidTimeSlot(timeRange) {
                            if (!timeRange || typeof timeRange !== 'string') return null;
                            
                            const timeParts = timeRange.split('ÔΩû');
                            if (timeParts.length !== 2) return null;
                            
                            const startTime = timeParts[0].trim();
                            const endTime = timeParts[1].trim();
                            
                            // Strict time format validation
                            const timeRegex = /^\d{1,2}:\d{2}$/;
                            if (timeRegex.test(startTime) && timeRegex.test(endTime)) {
                                return { start: startTime, end: endTime };
                            }
                            
                            return null;
                        }
                        
                        function createUltraSafeEvent(id, room, title, dateStr, timeSlot, rowIndex, slotIndex) {
                            console.log(`üö® [createUltraSafeEvent] === ENTRY POINT ===`);
                            console.log(`üö® [createUltraSafeEvent] Inputs:`, { id, room, title, dateStr, timeSlot, rowIndex, slotIndex });
                            
                            try {
                                // ABSOLUTE input validation
                                if (!id || !room || !title || !dateStr || !timeSlot) {
                                    console.error(`üö® [createUltraSafeEvent] CRITICAL: Missing required inputs`);
                                    return null;
                                }
                                
                                if (!timeSlot.start || !timeSlot.end) {
                                    console.error(`üö® [createUltraSafeEvent] CRITICAL: Invalid timeSlot`, timeSlot);
                                    return null;
                                }
                                
                                // Ultra-safe date normalization
                                const normalizedDate = ultraSafeDateNormalization(dateStr);
                                if (!normalizedDate) {
                                    console.error(`üö® [createUltraSafeEvent] CRITICAL: Date normalization failed for "${dateStr}"`);
                                    return null;
                                }
                                
                                // Create ISO datetime strings
                                const startDateTime = `${normalizedDate}T${timeSlot.start}:00`;
                                const endDateTime = `${normalizedDate}T${timeSlot.end}:00`;
                                
                                console.log(`üö® [createUltraSafeEvent] DateTime strings: "${startDateTime}" to "${endDateTime}"`);
                                
                                // Validate dates
                                const startDate = new Date(startDateTime);
                                const endDate = new Date(endDateTime);
                                
                                if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                                    console.error(`üö® [createUltraSafeEvent] CRITICAL: Invalid dates created`);
                                    return null;
                                }
                                
                                // Create unique event ID
                                const uniqueId = `${id}_${room.replace(/[()]/g, '')}_${rowIndex}_${slotIndex}`;
                                
                                const eventObj = {
                                    id: uniqueId,
                                    room: room,
                                    name: title,
                                    start: startDate.toISOString(),
                                    end: endDate.toISOString()
                                };
                                
                                console.log(`üö® [createUltraSafeEvent] ‚úÖ SUCCESS:`, eventObj);
                                return eventObj;
                                
                            } catch (error) {
                                console.error(`üö® [createUltraSafeEvent] EXCEPTION:`, error);
                                console.error(`üö® [createUltraSafeEvent] Stack:`, error.stack);
                                return null;
                            }
                        }
                        
                        function ultraSafeDateNormalization(dateString) {
                            if (!dateString || typeof dateString !== 'string' || dateString.trim() === '') {
                                console.error(`üö® [ultraSafeDateNormalization] Invalid input: "${dateString}"`);
                                return null;
                            }
                            
                            try {
                                const parts = dateString.trim().split('/');
                                if (parts.length === 3) {
                                    const year = parts[0];
                                    const month = String(parseInt(parts[1], 10)).padStart(2, '0');
                                    const day = String(parseInt(parts[2], 10)).padStart(2, '0');
                                    const result = `${year}-${month}-${day}`;
                                    console.log(`üö® [ultraSafeDateNormalization] "${dateString}" -> "${result}"`);
                                    return result;
                                }
                            } catch (error) {
                                console.error(`üö® [ultraSafeDateNormalization] Exception:`, error);
                            }
                            
                            console.error(`üö® [ultraSafeDateNormalization] Failed to normalize: "${dateString}"`);
                            return null;
                        }
                        
                        function parseRobustTimeValue(timeValue) {
                            if (!timeValue) return [];
                            
                            console.log(`üö® [csv] parseRobustTimeValue input: "${timeValue}"`);
                            
                            // Split by semicolon for multiple time ranges
                            const timeRanges = timeValue.split(';')
                                .map(t => t.trim())
                                .filter(t => t && t.length > 3); // Filter out incomplete times like "11"
                            
                            console.log(`üö® [csv] Split into ${timeRanges.length} time ranges:`, timeRanges);
                            
                            const parsedSlots = [];
                            
                            timeRanges.forEach((range, idx) => {
                                console.log(`üö® [csv] Processing time range ${idx + 1}: "${range}"`);
                                
                                // Replace various separators and full-width characters
                                let normalizedRange = range
                                    .replace(/Ôºö/g, ':')      // Full-width colon to half-width
                                    .replace(/„Äú/g, 'ÔΩû')      // Normalize wave dash
                                    .replace(/‚àí/g, 'ÔΩû')      // Em dash to wave dash
                                    .replace(/-/g, 'ÔΩû')      // Hyphen to wave dash
                                    .trim();
                                
                                console.log(`üö® [csv] Normalized range: "${normalizedRange}"`);
                                
                                // Split by wave dash or similar
                                const timeParts = normalizedRange.split('ÔΩû');
                                if (timeParts.length === 2) {
                                    const startTime = timeParts[0].trim();
                                    const endTime = timeParts[1].trim();
                                    
                                    console.log(`üö® [csv] Extracted times - Start: "${startTime}", End: "${endTime}"`);
                                    
                                    // Validate time format (HH:MM)
                                    const timeRegex = /^\d{1,2}:\d{2}$/;
                                    if (timeRegex.test(startTime) && timeRegex.test(endTime)) {
                                        parsedSlots.push({ start: startTime, end: endTime });
                                        console.log(`üö® [csv] ‚úÖ Added valid time slot: ${startTime} - ${endTime}`);
                                    } else {
                                        console.warn(`üö® [csv] ‚ùå Invalid time format - Start: "${startTime}", End: "${endTime}"`);
                                    }
                                } else {
                                    console.warn(`üö® [csv] ‚ùå Could not parse time range: "${range}" (parts: ${timeParts.length})`);
                                }
                            });
                            
                            console.log(`üö® [csv] parseRobustTimeValue result: ${parsedSlots.length} slots`, parsedSlots);
                            return parsedSlots;
                        }
                        
                        function parseComplexTimeValue(timeValue) {
                            if (!timeValue) return [];
                            
                            console.log(`üö® [csv] parseComplexTimeValue input: "${timeValue}"`);
                            
                            // Split by semicolon for multiple time ranges
                            const timeRanges = timeValue.split(';').map(t => t.trim()).filter(t => t);
                            console.log(`üö® [csv] Split into ${timeRanges.length} time ranges:`, timeRanges);
                            
                            const parsedSlots = [];
                            
                            timeRanges.forEach((range, idx) => {
                                console.log(`üö® [csv] Processing time range ${idx + 1}: "${range}"`);
                                
                                // Replace various separators and full-width characters
                                let normalizedRange = range
                                    .replace(/Ôºö/g, ':')      // Full-width colon to half-width
                                    .replace(/„Äú/g, 'ÔΩû')      // Normalize wave dash
                                    .replace(/‚àí/g, 'ÔΩû')      // Em dash to wave dash
                                    .replace(/-/g, 'ÔΩû');     // Hyphen to wave dash
                                
                                console.log(`üö® [csv] Normalized range: "${normalizedRange}"`);
                                
                                // Split by wave dash or similar
                                const timeParts = normalizedRange.split('ÔΩû');
                                if (timeParts.length === 2) {
                                    const startTime = timeParts[0].trim();
                                    const endTime = timeParts[1].trim();
                                    
                                    console.log(`üö® [csv] Extracted times - Start: "${startTime}", End: "${endTime}"`);
                                    
                                    if (startTime && endTime) {
                                        parsedSlots.push({ start: startTime, end: endTime });
                                        console.log(`üö® [csv] ‚úÖ Added time slot: ${startTime} - ${endTime}`);
                                    }
                                } else {
                                    console.warn(`üö® [csv] ‚ùå Could not parse time range: "${range}"`);
                                }
                            });
                            
                            console.log(`üö® [csv] parseComplexTimeValue result: ${parsedSlots.length} slots`, parsedSlots);
                            return parsedSlots;
                        }
                        
                        function createCompleteEvent(id, room, title, dateStr, timeSlot, rowIndex, slotIndex) {
                            try {
                                console.log(`üö® [csv] createCompleteEvent called with:`, {
                                    id, room, title, dateStr, timeSlot, rowIndex, slotIndex
                                });
                                
                                // Normalize date string from YYYY/M/D to YYYY-MM-DD
                                const normalizedDate = normalizeDateString(dateStr);
                                if (!normalizedDate) {
                                    console.error(`üö® [csv] Failed to normalize date: "${dateStr}"`);
                                    return null;
                                }
                                console.log(`üö® [csv] Normalized date: "${normalizedDate}"`);
                                
                                // Create full datetime strings
                                const startDateTime = `${normalizedDate}T${timeSlot.start}:00`;
                                const endDateTime = `${normalizedDate}T${timeSlot.end}:00`;
                                console.log(`üö® [csv] DateTime strings - Start: "${startDateTime}", End: "${endDateTime}"`);
                                
                                // Validate by creating Date objects
                                const startDate = new Date(startDateTime);
                                const endDate = new Date(endDateTime);
                                
                                if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                                    console.error(`üö® [csv] Invalid dates created:`, { startDateTime, endDateTime });
                                    return null;
                                }
                                
                                console.log(`üö® [csv] Valid dates created:`, { 
                                    start: startDate.toISOString(), 
                                    end: endDate.toISOString() 
                                });
                                
                                // Create unique event ID
                                const uniqueId = `${id}_${room.replace(/[()]/g, '')}_${rowIndex}_${slotIndex}`;
                                
                                const eventObj = {
                                    id: uniqueId,
                                    room: room,
                                    name: title,
                                    start: startDate.toISOString(),
                                    end: endDate.toISOString()
                                };
                                
                                console.log(`üö® [csv] ‚úÖ Complete event object created:`, eventObj);
                                return eventObj;
                                
                            } catch (error) {
                                console.error(`üö® [csv] ‚ùå Error in createCompleteEvent:`, error);
                                return null;
                            }
                        }
                        
                        function parseMultipleTimeSlots(timeValue) {
                            if (!timeValue) return [];
                            
                            console.log(`üö® [csv] Parsing multiple time slots from: "${timeValue}"`);
                            
                            // Split by semicolon for multiple time slots
                            const slots = timeValue.split(';').map(slot => slot.trim()).filter(slot => slot);
                            console.log(`üö® [csv] Split time slots:`, slots);
                            
                            const parsedSlots = [];
                            
                            slots.forEach(slot => {
                                const timeRange = parseTimeRange(slot);
                                if (timeRange.start && timeRange.end) {
                                    parsedSlots.push(timeRange);
                                }
                            });
                            
                            console.log(`üö® [csv] Parsed time slots:`, parsedSlots);
                            return parsedSlots;
                        }
                        
                        function createEventFromTimeSlot(row, rowIndex, room, name, purpose, dateStr, timeSlot) {
                            try {
                                // Normalize date format
                                const normalizedDate = normalizeDateString(dateStr);
                                if (!normalizedDate) {
                                    console.warn(`üö® [csv] Failed to normalize date: ${dateStr}`);
                                    return null;
                                }
                                
                                // Create ISO datetime strings
                                const startDateTime = `${normalizedDate}T${timeSlot.start}:00`;
                                const endDateTime = `${normalizedDate}T${timeSlot.end}:00`;
                                
                                // Validate dates
                                const startDate = new Date(startDateTime);
                                const endDate = new Date(endDateTime);
                                
                                if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                                    console.warn(`üö® [csv] Invalid date created:`, { startDateTime, endDateTime });
                                    return null;
                                }
                                
                                // Create unique ID
                                const eventId = row['ÂõûÁ≠îÁï™Âè∑'] || row['Âèó‰ªòÁï™Âè∑'] || 
                                              `csv_${Date.now()}_${rowIndex}_${Math.random().toString(36).substr(2, 9)}`;
                                
                                const eventObj = {
                                    id: `${eventId}_${room}_${timeSlot.start}`,
                                    room: room,
                                    name: purpose || name || 'ÊñΩË®≠Âà©Áî®',
                                    start: startDate.toISOString(),
                                    end: endDate.toISOString()
                                };
                                
                                console.log(`üö® [csv] Created event object:`, eventObj);
                                return eventObj;
                                
                            } catch (error) {
                                console.error(`üö® [csv] Error creating event:`, error);
                                return null;
                            }
                        }
                        
                        // üö® ENHANCED UTILITY FUNCTIONS FOR DATE/TIME PARSING
                        function parseTimeRange(timeStr) {
                            if (!timeStr) return { start: null, end: null };
                            
                            console.log(`üö® [csv] Parsing time string: "${timeStr}"`);
                            
                            // Replace full-width colons and various separators
                            const normalized = timeStr.replace(/Ôºö/g, ':').replace(/„Äú/g, 'ÔΩû').replace(/-/g, 'ÔΩû');
                            console.log(`üö® [csv] Normalized time string: "${normalized}"`);
                            
                            // Split by common separators
                            let parts = normalized.split('ÔΩû');
                            if (parts.length === 1) parts = normalized.split('-');
                            if (parts.length === 1) parts = normalized.split('~');
                            
                            console.log(`üö® [csv] Time parts after split:`, parts);
                            
                            if (parts.length === 2) {
                                const start = parts[0].trim();
                                const end = parts[1].trim();
                                
                                // Ensure HH:MM format
                                const formatTime = (time) => {
                                    if (time.includes(':')) return time;
                                    if (time.length === 4) return `${time.substr(0, 2)}:${time.substr(2, 2)}`;
                                    if (time.length === 3) return `${time.substr(0, 1)}:${time.substr(1, 2)}`;
                                    return time;
                                };
                                
                                const formattedStart = formatTime(start);
                                const formattedEnd = formatTime(end);
                                
                                console.log(`üö® [csv] Formatted time range:`, { start: formattedStart, end: formattedEnd });
                                return { start: formattedStart, end: formattedEnd };
                            }
                            
                            console.log(`üö® [csv] Failed to parse time range`);
                            return { start: null, end: null };
                        }
                        
                        function normalizeDateString(dateStr) {
                            if (!dateStr) return null;
                            
                            console.log(`üö® [csv] Normalizing date string: "${dateStr}"`);
                            
                            // Handle various date formats: YYYY/M/D, YYYY-M-D, etc.
                            let normalized = dateStr.replace(/[\/\-]/g, '-');
                            
                            // Ensure YYYY-MM-DD format
                            const parts = normalized.split('-');
                            if (parts.length === 3) {
                                const year = parts[0].padStart(4, '0');
                                const month = parts[1].padStart(2, '0');
                                const day = parts[2].padStart(2, '0');
                                normalized = `${year}-${month}-${day}`;
                            }
                            
                            console.log(`üö® [csv] Normalized date: "${normalized}"`);
                            return normalized;
                        }
                        
                        console.log('üö® [csv] FINAL VALIDATION RESULTS:');
                        console.log('üö® [csv] Valid events for API submission:', validEvents);
                        console.log('üö® [csv] Valid events count:', validEvents.length);
                        console.log('üö® [csv] Invalid rows count:', errors.length);
                        
                        if (validEvents.length === 0) {
                            console.error('üö®üö®üö® [csv] ‚ùå NO VALID EVENTS FOUND - COMPREHENSIVE FINAL ANALYSIS:');
                            console.error('üö® [csv] ‚ùå Total rows processed:', results.data.length);
                            console.error('üö® [csv] ‚ùå Total errors recorded:', errors.length);
                            console.error('üö® [csv] ‚ùå CSV Headers detected (first 30):', Object.keys(results.data[0] || {}).slice(0, 30));
                            
                            console.error('üö® [csv] FINAL VALIDATION ERRORS (DETAILS):');
                            console.error(JSON.stringify(errors, null, 2));
                            
                            // Analyze common failure patterns
                            const failureAnalysis = {
                                totalRows: results.data.length,
                                rowsWithErrors: errors.length,
                                commonIssues: {
                                    missingDate: errors.filter(e => e.errors.some(err => err.includes('date'))).length,
                                    missingTimeData: errors.filter(e => e.errors.some(err => err.includes('ÊôÇÈñì'))).length,
                                    noRoomColumns: errors.filter(e => 
                                        e.roomColumnAnalysis && e.roomColumnAnalysis.every(room => !room.hasData)
                                    ).length
                                },
                                sampleFailedRow: errors[0] || null,
                                availableHeaders: Object.keys(results.data[0] || {}),
                                roomRelatedHeaders: Object.keys(results.data[0] || {}).filter(key => 
                                    key.includes('‰ºöË≠∞ÂÆ§') || key.includes('Áõ∏Ë´áÂÆ§') || 
                                    key.includes('„ÉÜ„É¨„ÉØ„Éº„ÇØ') || key.includes('ÊôÇÈñì')
                                )
                            };
                            
                            console.error('üö® [csv] ‚ùå FAILURE ANALYSIS:', JSON.stringify(failureAnalysis, null, 2));
                            
                            // Show detailed error message
                            const errorSummary = errors.length > 0 
                                ? `${errors.length}Ë°å„Åß„Ç®„É©„Éº: ${errors.slice(0, 2).map(e => e.errors.join(', ')).join(' | ')}`
                                : 'CSV„Éá„Éº„Çø„ÅåË™çË≠ò„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü';
                            
                            showStatusBadge(`Âèñ„ÇäËæº„ÅøÂèØËÉΩ„Å™„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì - ${errorSummary}`, 'error');
                            return;
                        } else {
                            console.log('üö® [csv] ‚úÖ SUCCESS: Found', validEvents.length, 'valid events');
                            validEvents.forEach((event, idx) => {
                                console.log(`üö® [csv] ‚úÖ Valid Event ${idx + 1}:`, {
                                    id: event.id,
                                    room: event.room,
                                    name: event.name,
                                    start: event.start,
                                    end: event.end
                                });
                            });
                        }
                        
                        // Send to API with bulk flag
                        try {
                            console.log('üö® [csv] Sending to API /api/logo?bulk=1 with', validEvents.length, 'events');
                            
                            const response = await fetch('/api/logo?bulk=1', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({ events: validEvents })
                            });
                            
                            console.log('üö® [csv] API response status:', response.status);
                            console.log('üö® [csv] API response ok:', response.ok);
                            
                            const result = await response.json();
                            console.log('üö® [csv] API response data:', result);
                            
                            if (response.ok) {
                                const message = errors.length > 0 
                                    ? `${result.imported || validEvents.length}‰ª∂Âèñ„ÇäËæº„ÅøÂÆå‰∫Ü / ${errors.length}‰ª∂„Çπ„Ç≠„ÉÉ„Éó`
                                    : `${result.imported || validEvents.length}‰ª∂Âèñ„ÇäËæº„ÅøÂÆå‰∫Ü`;
                                    
                                console.log('üö® [csv] ‚úÖ SUCCESS:', message);
                                showStatusBadge(message, 'success');
                                
                                // Refresh calendar to show new events
                                console.log('üö® [csv] Refreshing calendar with new events...');
                                setTimeout(() => fetchEvents(), 1000);
                                
                                // Clear file input
                                if (fileInput) fileInput.value = '';
                            } else {
                                console.error('üö® [csv] ‚ùå API ERROR:', result);
                                if (response.status === 422) {
                                    showStatusBadge('CSV„Ç®„É©„Éº: Ë©≥Á¥∞„ÅØ„Ç≥„É≥„ÇΩ„Éº„É´', 'error');
                                } else {
                                    showStatusBadge('„Çµ„Éº„Éê„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü', 'error');
                                }
                            }
                            
                        } catch (apiError) {
                            console.error('üö® [csv] ‚ùå API request failed:', apiError);
                            showStatusBadge('„Çµ„Éº„Éê„Å®„ÅÆÈÄö‰ø°„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü', 'error');
                        }
                    },
                    error: function(error) {
                        console.error('üö® [csv] ‚ùå CSV parse error:', error);
                        showStatusBadge('CSV„Éï„Ç°„Ç§„É´„ÅÆËß£Êûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
                    }
                });
                
            } catch (fileError) {
                console.error('üö® [csv] ‚ùå File read error:', fileError);
                showStatusBadge('„Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            } finally {
                // Re-enable button
                if (uploadBtn) {
                    uploadBtn.disabled = false;
                    uploadBtn.textContent = 'üìÑ CSV Âèñ„ÇäËæº„Åø';
                }
            }
        };
        
        window.toggleAdminMode = function() {
            console.log('üö® [admin] toggleAdminMode function called - WINDOW VERSION');
            
            const adminPanel = document.getElementById('adminPanel');
            const adminToggle = document.getElementById('adminToggle');
            
            if (!adminPanel || !adminToggle) {
                console.error('üö® [admin] Required elements not found');
                return;
            }
            
            adminMode = !adminMode;
            adminPanel.style.display = adminMode ? 'block' : 'none';
            adminToggle.textContent = adminMode ? 'üìÖ „Ç´„É¨„É≥„ÉÄ„Éº' : 'üîß ÁÆ°ÁêÜ„É¢„Éº„Éâ';
            adminToggle.classList.toggle('active', adminMode);
            
            if (adminMode) {
                refreshEventsList();
            }
            
            console.log('üö® [admin] Admin mode toggled to:', adminMode);
        };
        
        window.deleteEvent = function(eventId) {
            console.log('üö® [admin] deleteEvent called for:', eventId);
            if (!confirm(`„Ç§„Éô„É≥„Éà ID: ${eventId} „ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) {
                return;
            }
            
            // Delete logic would go here
            showStatusBadge('„ÉÜ„Çπ„ÉàÔºöÂâäÈô§Ê©üËÉΩ„ÅåÂãï‰Ωú„Åó„Å¶„ÅÑ„Åæ„Åô', 'success');
        };
        
        window.refreshEventsList = function() {
            console.log('üö® [admin] refreshEventsList called');
            const eventsList = document.getElementById('eventsList');
            if (eventsList) {
                eventsList.innerHTML = '<p>„ÉÜ„Çπ„ÉàÔºöÁÆ°ÁêÜ„Éë„Éç„É´„ÅåÂãï‰Ωú„Åó„Å¶„ÅÑ„Åæ„Åô</p>';
            }
        };
        
        // „Ç§„Éô„É≥„Éà„ÅÆÊôÇÈñìË°®Á§∫„ÇíÊï¥ÂΩ¢„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞
        function formatEventTime(date) {
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${hours}Ôºö${minutes}`;
        }
        
        // Utility functions
        const showStatusBadge = (message, type) => {
            const badge = document.getElementById('statusBadge');
            if (badge) {
                badge.textContent = message;
                badge.className = `status-badge status-${type}`;
                badge.style.display = 'inline-block';
                
                setTimeout(() => {
                    badge.style.display = 'none';
                }, 5000);
            }
        };
        
        const showNoEvents = () => {
            const calendar = document.getElementById('calendar');
            const noEvents = document.getElementById('noEvents');
            if (calendar) calendar.style.display = 'none';
            if (noEvents) noEvents.style.display = 'block';
        };
        
        // Initialize calendar with comprehensive error handling
        const initCalendar = () => {
            console.log('üö® [calendar] Initializing calendar...');
            const calendarElement = document.getElementById('calendar');
            if (!calendarElement) {
                console.error('‚ùå [calendar] Calendar element not found!');
                return;
            }

            // Toast UI Calendar„É©„Ç§„Éñ„É©„É™„ÅÆË™≠„ÅøËæº„ÅøÁä∂Ê≥Å„ÇíÁ¢∫Ë™ç
            const isToastUiModern = typeof toastui !== 'undefined' && typeof toastui.Calendar !== 'undefined';
            const isTuiLegacy = typeof tui !== 'undefined' && typeof tui.Calendar !== 'undefined';

            if (!isToastUiModern && !isTuiLegacy) {
                console.error('‚ùå [calendar] Toast UI Calendar library not available!');
                const statusElement = document.getElementById('statusMessage');
                if (statusElement) {
                    statusElement.textContent = '„Ç®„É©„Éº: „Ç´„É¨„É≥„ÉÄ„Éº„É©„Ç§„Éñ„É©„É™„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ';
                    statusElement.style.color = 'red';
                    statusElement.style.display = 'block';
                }
                return;
            }

            console.log('üö® [calendar] Checking library availability:');
            console.log('üö® [calendar] - toastui:', isToastUiModern);
            console.log('üö® [calendar] - toastui.Calendar:', isToastUiModern);
            console.log('üö® [calendar] - tui (legacy):', isTuiLegacy);
            console.log('üö® [calendar] Calendar element found:', !!calendarElement);

            const calendarOptions = {
                defaultView: 'month', // „Ç´„É¨„É≥„ÉÄ„Éº„ÅÆ„Éá„Éï„Ç©„É´„ÉàË°®Á§∫„ÇíÊúàË°®Á§∫„Å´Ë®≠ÂÆö
                date: new Date(),     // „Ç´„É¨„É≥„ÉÄ„Éº„ÅÆÂàùÊúüË°®Á§∫Êó•„Çí‰ªäÊó•„ÅåÂê´„Åæ„Çå„ÇãÊúà„Å´Ë®≠ÂÆö
                usageStatistics: false, // Áµ±Ë®àÊÉÖÂ†±„ÅÆÈÄÅ‰ø°„ÇíÁÑ°ÂäπÂåñÔºà‰ªªÊÑèÔºâ
                useCreationPopup: false,
                useDetailPopup: true,
                calendars: ROOMS.map((room) => ({
                    id: room,
                    name: room,
                    backgroundColor: ROOM_COLORS[room] || '#007bff',
                    borderColor: ROOM_COLORS[room] || '#007bff',
                    dragBgColor: ROOM_COLORS[room] || '#007bff'
                })),
                // „Ç§„Éô„É≥„ÉàË°®Á§∫„ÅÆ„Ç´„Çπ„Çø„Éû„Ç§„Ç∫
                template: {
                    // ÊôÇÈñìÊåáÂÆö„Ç§„Éô„É≥„Éà„ÅÆË°®Á§∫„ÉÜ„É≥„Éó„É¨„Éº„Éà
                    time: function (event) {
                        // event.start „Å® event.end „ÅØ Date „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÔºàTUI Calendar„ÅåISOÊñáÂ≠óÂàó„Åã„ÇâÂ§âÊèõÊ∏à„ÅøÔºâ
                        const startDate = new Date(event.start.getTime());
                        const endDate = new Date(event.end.getTime());

                        const displayTime = `${formatEventTime(startDate)}„Äú${formatEventTime(endDate)}`;

                        // ÂêçÂâç„Å®ÊôÇÈñì„ÇíË°®Á§∫„Åó„Åæ„Åô
                        return `<span style="font-weight: bold;">${event.title}</span><br>${displayTime}`;
                    },
                    // ÂÖ®Êó•„Ç§„Éô„É≥„Éà„ÅÆË°®Á§∫„ÉÜ„É≥„Éó„É¨„Éº„ÉàÔºàCSV„Å´„ÅØ„Å™„ÅÑ„ÅåÂøµ„ÅÆ„Åü„ÇÅÔºâ
                    allday: function (event) {
                        return `<span style="font-weight: bold;">${event.title}</span>`;
                    },
                    // „Éû„Ç§„É´„Çπ„Éà„Éº„É≥„Ç§„Éô„É≥„Éà„ÅÆË°®Á§∫„ÉÜ„É≥„Éó„É¨„Éº„ÉàÔºàCSV„Å´„ÅØ„Å™„ÅÑ„ÅåÂøµ„ÅÆ„Åü„ÇÅÔºâ
                    milestone: function (event) {
                        return `<span style="font-weight: bold;">${event.title}</span>`;
                    },
                    monthDayname: (dayname) => {
                        const dayNames = ['Êó•', 'Êúà', 'ÁÅ´', 'Ê∞¥', 'Êú®', 'Èáë', 'Âúü'];
                        return `<span class="toastui-calendar-weekday-name">${dayNames[dayname.day] || dayname.label}</span>`;
                    }
                },
                // ÊúàË°®Á§∫„ÅÆË®≠ÂÆöÔºàÊõúÊó•Âêç„ÇíÊó•Êú¨Ë™ûÂåñÔºâ
                month: {
                    daynames: ['Êó•', 'Êúà', 'ÁÅ´', 'Ê∞¥', 'Êú®', 'Èáë', 'Âúü'],
                    visibleWeeksCount: 6, // Â∏∏„Å´6ÈÄ±ÈñìË°®Á§∫„ÅßÂõ∫ÂÆöÔºà„Ç´„É¨„É≥„ÉÄ„Éº„ÅÆÈ´ò„Åï„ÅåÂÆâÂÆö„Åó„Åæ„ÅôÔºâ
                    visibleEventCount: 10, // „Çª„É´„ÅÇ„Åü„Çä„ÅÆË°®Á§∫„Ç§„Éô„É≥„ÉàÊï∞„ÇíÂ¢óÂä†
                    moreLayerSize: {
                        height: 'auto' // „Äåmore„Äç„É¨„Ç§„É§„Éº„ÅÆÈ´ò„Åï„ÇíËá™ÂãïË™øÊï¥
                    },
                    grid: {
                        header: {
                            height: 34
                        },
                        footer: {
                            height: 34
                        }
                    }
                },
                // ÈÄ±Ë°®Á§∫„ÅÆË®≠ÂÆöÔºàÊõúÊó•Âêç„ÇíÊó•Êú¨Ë™ûÂåñ„ÄÅÊúàË°®Á§∫„Å™„ÅÆ„Åß‰ªäÂõû„ÅØÁõ¥Êé•ÂΩ±Èüø„Åó„Å™„ÅÑ„ÅåÂÆöÁæ©Ôºâ
                week: {
                    daynames: ['Êó•', 'Êúà', 'ÁÅ´', 'Ê∞¥', 'Êú®', 'Èáë', 'Âúü'],
                },
                // „Çø„Ç§„É†„Çæ„Éº„É≥Ë®≠ÂÆöÔºàÊó•Êú¨ÊôÇÈñì„Å´Âõ∫ÂÆöÔºâ
                timezone: {
                    zones: [
                        {
                            timezoneName: 'Asia/Tokyo',
                            displayLabel: 'GMT+09:00',
                        },
                    ],
                },
            };

            try {
                let calendarInstance;
                // Âà©Áî®ÂèØËÉΩ„Å™„É©„Ç§„Éñ„É©„É™„Å´Âøú„Åò„Å¶„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÁîüÊàê
                if (isToastUiModern) {
                    console.log('üö® [calendar] Creating calendar instance using toastui.Calendar...');
                    calendarInstance = new toastui.Calendar(calendarElement, calendarOptions);
                } else {
                    console.log('üö® [calendar] Creating calendar instance using tui.Calendar (legacy)...');
                    calendarInstance = new tui.Calendar(calendarElement, calendarOptions);
                }

                // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Å®„Åó„Å¶„Ç´„É¨„É≥„ÉÄ„Éº„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å´„Ç¢„ÇØ„Çª„Çπ„Åß„Åç„Çã„Çà„ÅÜ„Å´Ë®≠ÂÆö
                window.calendar = calendarInstance;
                calendar = calendarInstance;

                console.log('üö® [calendar] ‚úÖ Toast UI Calendar initialized successfully!');
                console.log('üö® [calendar] Calendar instance:', calendar);
                
                // Initialize calendar display
                const loading = document.getElementById('loading');
                if (loading) loading.style.display = 'none';
                calendarElement.style.display = 'block';
                
            } catch (error) {
                console.error('üö® [calendar] ‚ùå Calendar initialization failed:', error);
                console.error('üö® [calendar] Error details:', error.message);
                console.error('üö® [calendar] Stack trace:', error.stack);
                
                // Show error message in calendar container
                calendarElement.innerHTML = `<div style="text-align: center; padding: 40px; color: #dc3545; font-size: 18px;"><strong>‚ö†Ô∏è „Ç´„É¨„É≥„ÉÄ„Éº„ÅÆÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü</strong><br><small>${error.message}</small></div>`;
            }
        };
        
        // Check environment setup
        async function checkEnvironment() {
            console.log('üö® [env] Checking Vercel KV environment setup...');
            // Vercel CLI„ÅßË®≠ÂÆö„Åó„ÅüÁí∞Â¢ÉÂ§âÊï∞„ÅØVercel„Éá„Éó„É≠„Ç§ÊôÇ„Å´„ÅØËá™ÂãïÁöÑ„Å´
            // process.env.VITE_KV_REST_API_URL „Å™„Å©„Å®„Åó„Å¶Âà©Áî®ÂèØËÉΩ„Åß„Åô„Åå„ÄÅ
            // ÈùôÁöÑ„Å™HTML„Éï„Ç°„Ç§„É´„Åã„ÇâÁõ¥Êé•„Ç¢„ÇØ„Çª„Çπ„Åô„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Éì„É´„ÉâÊôÇ„Å´Âüã„ÇÅËæº„ÇÄ„Åã„ÄÅ
            // APIÁµåÁî±„ÅßÂèñÂæó„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
            // ‰ªäÂõû„ÅØÁ∞°ÊòìÁöÑ„Å´window„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å´Áõ¥Êé•ÂÆöÁæ©„Åï„Çå„Çã„Åì„Å®„ÇíÊÉ≥ÂÆö„Åó„Åæ„Åô„ÄÇ
            // ‚Äª ÂÆüÈöõ„ÅÆVercel„ÅÆÁí∞Â¢ÉÂ§âÊï∞„Ç¢„ÇØ„Çª„Çπ„ÅØ„Çµ„Éº„Éê„Éº„Çµ„Ç§„ÉâÔºà/api/*Ôºâ„ÅßË°å„Çè„Çå„Åæ„Åô„ÄÇ
            // „Åì„Åì„ÅØ„Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„ÅåAPI„Ç®„É©„Éº„ÇíÊ≠£„Åó„Åè„Éè„É≥„Éâ„É™„É≥„Ç∞„Åô„Çã„Åü„ÇÅ„ÅÆ„É≠„Ç∞„Å®UIÂá¶ÁêÜ„Åß„Åô„ÄÇ

            // „Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„ÅßÁõ¥Êé•Áí∞Â¢ÉÂ§âÊï∞„Å´„Ç¢„ÇØ„Çª„Çπ„Åô„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ
            // „Åó„Åã„Åó„ÄÅAPI„Åã„Çâ„ÅÆÂøúÁ≠î„ÅßÁí∞Â¢ÉÂ§âÊï∞„ÅÆÂïèÈ°å„ÅåÁ§∫„Åï„Çå„Çã„Åü„ÇÅ„ÄÅ
            // „Åù„ÅÆÊÉÖÂ†±„ÇíÂèó„ÅëÂèñ„Å£„ÅüÈöõ„Å´„É¶„Éº„Ç∂„Éº„Å´ÈÄöÁü•„Åô„Çã„É≠„Ç∏„ÉÉ„ÇØ„ÇíÂº∑Âåñ„Åó„Åæ„Åô„ÄÇ
            // ÁèæÁä∂„ÅÆcheckEnvironment„ÅØKV_REST_API_URL„Å®TOKEN„ÅÆÂ≠òÂú®„ÉÅ„Çß„ÉÉ„ÇØ„Åß„ÅØ„Å™„Åè„ÄÅ
            // API„ÅÆ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„Å´Âøú„Åò„Å¶UI„ÇíÊõ¥Êñ∞„Åô„Çã„Åü„ÇÅ„Å´Âà©Áî®„Åó„Åæ„Åô„ÄÇ

            // KVË®≠ÂÆö„ÅÆÁúü„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„ÅØ /api/events „Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„ÅßË°å„Çè„Çå„Çã„Åü„ÇÅ„ÄÅ
            // „Åì„Åì„Åß„ÅØÂçò„Å´await new Promise(r => setTimeout(r, 0)); „ÇíÂâäÈô§„Åó„ÄÅ
            // ÂÆüÈöõ„Å´„ÅØ„Éï„Çß„ÉÉ„ÉÅÈñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åô„Åì„Å®„ÅßAPI„Åã„Çâ„ÅÆÂøúÁ≠î„ÇíÂæÖ„Å°„Åæ„Åô„ÄÇ
            // „Åì„ÅÆÈñ¢Êï∞„ÅØUI„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫„Å´ÁâπÂåñ„Åï„Åõ„Åæ„Åô„ÄÇ

            // UI„Å´Ë°®Á§∫„Åô„Çã„Åü„ÇÅ„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„É°„ÉÉ„Çª„Éº„Ç∏Ë¶ÅÁ¥†„ÇíÂèñÂæó
            const statusElement = document.getElementById('statusMessage');
            if (!statusElement) {
                console.warn('‚ö†Ô∏è [env] statusMessage element not found in DOM.');
            }

            // fetchEvents„ÅåAPI„Ç®„É©„Éº„ÇíÊ§úÂá∫„Åó„ÅüÂ†¥Âêà„Å´„ÄÅ„Åì„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÅåË°®Á§∫„Åï„Çå„Çã„Çà„ÅÜ„Å´„Åó„Åæ„Åô„ÄÇ
            // „Åì„ÅÆcheckEnvironmentÈñ¢Êï∞Ëá™‰Ωì„ÅØ„ÄÅ„Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Åã„Çâ„ÅØÁõ¥Êé•KV_REST_API_URL„Å™„Å©„ÅÆ
            // Â≠òÂú®„ÇíÂà§ÂÆö„Åß„Åç„Å™„ÅÑ„Åü„ÇÅ„ÄÅAPI„Åã„Çâ„ÅÆ„Ç®„É©„ÉºÂøúÁ≠î„Å´‰æùÂ≠ò„Åó„Åæ„Åô„ÄÇ
            // „Åù„ÅÆ„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØÁõ¥Êé•ÁöÑ„Å™„ÉÅ„Çß„ÉÉ„ÇØ„ÅØË°å„ÅÑ„Åæ„Åõ„Çì„ÄÇ

            return true; // Â∏∏„Å´true„ÇíËøî„Åó„ÄÅfetchEvents„Å´ÈÄ≤„Åæ„Åõ„Çã„ÄÇ„Ç®„É©„Éº„ÅØfetchEvents„ÅßÂá¶ÁêÜ„ÄÇ
        }
        
        // Create test events for demo when API fails
        const createTestEvents = () => {
            console.log('üö® [demo] Creating test events for demonstration...');
            
            const testEvents = [
                {
                    id: 'test-1',
                    room: '‰ºöË≠∞ÂÆ§(„Åï„Åè„Çâ)',
                    name: '„ÉÜ„Çπ„Éà„Ç§„Éô„É≥„Éà1',
                    start: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // Tomorrow
                    end: new Date(Date.now() + 24 * 60 * 60 * 1000 + 2 * 60 * 60 * 1000).toISOString() // Tomorrow + 2 hours
                },
                {
                    id: 'test-2',
                    room: '„ÉÜ„É¨„ÉØ„Éº„ÇØ„É´„Éº„É†A',
                    name: '„ÉÜ„Çπ„Éà„Ç§„Éô„É≥„Éà2',
                    start: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000).toISOString(), // Day after tomorrow
                    end: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000 + 3 * 60 * 60 * 1000).toISOString() // Day after tomorrow + 3 hours
                }
            ];
            
            return testEvents;
        };
        
        // Fetch events with calendar dependency check
        async function fetchEvents() {
            console.log('üö® [calendar] Fetching events...');
            // const envReady = await checkEnvironment(); // „Åì„ÅÆÂëº„Å≥Âá∫„Åó„ÅØ‰∏çË¶Å„ÄÅAPI„Åã„Çâ„ÅÆÂøúÁ≠î„ÅßÂà§Êñ≠

            const statusElement = document.getElementById('statusMessage');
            if (statusElement) {
                statusElement.textContent = '„Ç§„Éô„É≥„Éà„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø‰∏≠...'; // Ë™≠„ÅøËæº„Åø‰∏≠„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏
                statusElement.style.color = 'gray';
                statusElement.style.display = 'block';
            }
            
            // Only proceed if calendar is initialized
            if (!calendar) {
                console.warn('üö® [calendar] Calendar not initialized. Skipping event fetch.');
                if (statusElement) {
                    statusElement.textContent = '„Ç´„É¨„É≥„ÉÄ„Éº„ÅåÂàùÊúüÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ';
                    statusElement.style.color = 'red';
                }
                showNoEvents();
                return;
            }
            
            try {
                console.log('üö® [calendar] Making API request to /api/events...');
                const response = await fetch('/api/events');
                console.log(`üö® [calendar] API response status: ${response.status}`);
                console.log(`üö® [calendar] API response ok: ${response.ok}`);
                console.log('üö® [calendar] API response headers:', Object.fromEntries(response.headers.entries()));

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error(`üö® [calendar] ‚ùå API ERROR - Status: ${response.status}`);
                    console.error(`üö® [calendar] ‚ùå API ERROR - Response: ${JSON.stringify(errorData)}`);
                    console.error(`üö® [calendar] ‚ùå API ERROR - Parsed JSON:`, errorData);

                    if (errorData.error && errorData.error.includes("ENV not set")) {
                        console.error('üö® [calendar] ‚ùå VERCEL KV ENVIRONMENT NOT CONFIGURED!');
                        console.error('üö® [calendar] ‚ùå Please set KV_REST_API_URL and KV_REST_API_TOKEN in Vercel dashboard');
                        if (statusElement) {
                            statusElement.textContent = '„Ç®„É©„Éº: Vercel KV„Éá„Éº„Çø„Éô„Éº„ÇπË®≠ÂÆö„ÅåÂÆå‰∫Ü„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇVercel„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„ÅßKV_REST_API_URL„Å®KV_REST_API_TOKEN„ÇíË®≠ÂÆö„Åó„ÄÅÂÜç„Éá„Éó„É≠„Ç§„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
                            statusElement.style.color = 'red';
                        }
                    } else {
                        if (statusElement) {
                            statusElement.textContent = `„Ç§„Éô„É≥„Éà„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${errorData.error || response.statusText}`;
                            statusElement.style.color = 'red';
                        }
                    }
                    throw new Error(`API request failed with status ${response.status}: ${errorData.error || response.statusText}`);
                }

                const data = await response.json();
                console.log('üö® [calendar] ‚úÖ Events fetched successfully:', data);
                if (statusElement) {
                    statusElement.textContent = '„Ç§„Éô„É≥„Éà„Éá„Éº„Çø„ÅåÊ≠£Â∏∏„Å´Ë™≠„ÅøËæº„Åæ„Çå„Åæ„Åó„Åü„ÄÇ';
                    statusElement.style.color = 'green';
                    // Hide status message after 3 seconds on success
                    setTimeout(() => {
                        statusElement.style.display = 'none';
                    }, 3000);
                }
                
                if (!data.events || !Array.isArray(data.events) || data.events.length === 0) {
                    console.log('üö® [calendar] No events found in API response');
                    showNoEvents();
                    return;
                }
                
                displayEvents(data.events);
                
            } catch (error) {
                console.error('üö® [calendar] ‚ùå Error fetching events:', error);
                if (statusElement) {
                    statusElement.textContent = '„Ç§„Éô„É≥„Éà„Éá„Éº„Çø„ÅÆÂèñÂæó‰∏≠„Å´‰∫àÊúü„Åõ„Å¨„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Ç≥„É≥„ÇΩ„Éº„É´„É≠„Ç∞„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
                    statusElement.style.color = 'red';
                }
                const loading = document.getElementById('loading');
                if (loading) loading.textContent = '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü';
            }
        }
        
        // Common function to display events on calendar
        const displayEvents = (events) => {
            console.log('üö® [calendar] Displaying events:', events.length);
            
            if (!calendar) {
                console.error('üö® [calendar] ‚ùå Calendar not initialized, cannot display events');
                return;
            }
            
            if (!events || events.length === 0) {
                console.log('üö® [calendar] No events to display');
                showNoEvents();
                return;
            }
            
            // Process and filter events
            const filteredEvents = filterEventsBy30Days(events);
            console.log('üö® [calendar] Filtered events (30 days):', filteredEvents.length);
            
            if (filteredEvents.length === 0) {
                showNoEvents();
                return;
            }
            
            // Show calendar and hide other states
            const calendarEl = document.getElementById('calendar');
            const noEvents = document.getElementById('noEvents');
            const loading = document.getElementById('loading');
            
            if (loading) loading.style.display = 'none';
            if (noEvents) noEvents.style.display = 'none';
            if (calendarEl) calendarEl.style.display = 'block';
            
            // Convert and add events to calendar
            const calendarEvents = convertToCalendarEvents(filteredEvents);
            console.log('üö® [calendar] Calendar events prepared:', calendarEvents);
            
            try {
                calendar.clear();
                calendar.createEvents(calendarEvents);
                console.log('üö® [calendar] ‚úÖ Events successfully added to calendar!');
                console.log('üö® [calendar] ‚úÖ Calendar should now be visible with', calendarEvents.length, 'events');
            } catch (eventError) {
                console.error('üö® [calendar] ‚ùå Error adding events to calendar:', eventError);
                
                // Show error in calendar container
                const calendarEl = document.getElementById('calendar');
                if (calendarEl) {
                    calendarEl.innerHTML = `<div style="text-align: center; padding: 40px; color: #dc3545; font-size: 18px;"><strong>‚ö†Ô∏è „Ç§„Éô„É≥„ÉàË°®Á§∫„Ç®„É©„Éº</strong><br><small>${eventError.message}</small></div>`;
                }
            }
        };
        
        // Enhanced utility functions
        const filterEventsBy30Days = (events) => {
            const now = new Date();
            const endDate = new Date(now.getTime() + HORIZON_DAYS * 24 * 60 * 60 * 1000);
            
            return events.filter(event => {
                const eventDate = new Date(event.start);
                return eventDate >= now && eventDate <= endDate;
            });
        };
        
        const convertToCalendarEvents = (apiEvents) => {
            return apiEvents.map(event => {
                const startDate = new Date(event.start);
                const endDate = new Date(event.end);
                
                return {
                    id: event.id.toString(),
                    calendarId: event.room,
                    title: `${event.name}`, // template.time function „Åß‰ΩøÁî®„Åï„Çå„Çã
                    category: 'time',
                    start: startDate,
                    end: endDate,
                    backgroundColor: ROOM_COLORS[event.room] || '#007bff',
                    borderColor: ROOM_COLORS[event.room] || '#007bff',
                    color: '#ffffff'
                };
            });
        };
        
        console.log('üö® [EMERGENCY] All functions registered to window object');
        console.log('üö® [EMERGENCY] uploadCSV available:', typeof window.uploadCSV);
        console.log('üö® [EMERGENCY] toggleAdminMode available:', typeof window.toggleAdminMode);
        
        // üö® DOMContentLoaded - ATTACH EVENT LISTENERS
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üö® [EMERGENCY] DOMContentLoaded fired - Starting UI binding');
            
            // CSV Upload Button
            const csvUploadBtn = document.getElementById('csvUploadBtn');
            if (csvUploadBtn) {
                console.log('üö® [app] CSV button found:', csvUploadBtn);
                csvUploadBtn.addEventListener('click', () => {
                    console.log('üö® [csv] CSV upload button clicked via addEventListener');
                    window.uploadCSV();
                });
                console.log('üö® [app] CSV button event listener attached');
            } else {
                console.error('üö® [app] ERROR: CSV upload button NOT FOUND');
            }
            
            // Admin Toggle Button
            const adminToggle = document.getElementById('adminToggle');
            if (adminToggle) {
                console.log('üö® [app] Admin toggle found:', adminToggle);
                adminToggle.addEventListener('click', () => {
                    console.log('üö® [admin] Admin toggle clicked via addEventListener');
                    window.toggleAdminMode();
                });
                console.log('üö® [app] Admin toggle event listener attached');
            } else {
                console.error('üö® [app] ERROR: Admin toggle button NOT FOUND');
            }
            
            // Refresh Button
            const refreshBtn = document.getElementById('refreshBtn');
            if (refreshBtn) {
                console.log('üö® [app] Refresh button found:', refreshBtn);
                refreshBtn.addEventListener('click', () => {
                    console.log('üö® [admin] Refresh button clicked via addEventListener');
                    window.refreshEventsList();
                });
                console.log('üö® [app] Refresh button event listener attached');
            } else {
                console.error('üö® [app] ERROR: Refresh button NOT FOUND');
            }
            
            // Initialize calendar FIRST, then check environment and fetch events
            console.log('üö® [EMERGENCY] Starting calendar initialization...');
            initCalendar();
            
            // Wait a bit for calendar to initialize, then check environment and fetch events
            setTimeout(async () => {
                console.log('üö® [EMERGENCY] Starting environment check and event fetch...');
                
                // Check environment setup first
                const envOk = await checkEnvironment();
                
                if (envOk) {
                    console.log('üö® [EMERGENCY] Environment OK, fetching real events...');
                    fetchEvents();
                } else {
                    console.warn('üö® [EMERGENCY] Environment issues detected, will show fallback UI');
                    // fetchEvents() will handle the fallback UI display
                    fetchEvents();
                }
            }, 500);
            
            console.log('üö® [EMERGENCY] UI binding complete - ALL BUTTONS SHOULD WORK NOW');
        });
        
        console.log('üö® [EMERGENCY] Script execution complete - Functions ready');
    </script>
</body>
</html>